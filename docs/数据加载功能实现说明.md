# 数据加载功能实现说明

## 1. 功能概述

数据加载功能负责从 `data` 目录自动读取 CSV 格式的时间序列数据文件，并进行初步处理，为后续的数据分析和预测提供基础数据支持。

## 2. 后端实现逻辑

### 2.1 核心功能
- 自动扫描 `data` 目录下的所有 CSV 文件
- 读取并解析 CSV 文件内容
- 验证数据格式（必须包含 time, ci_id, value 字段）
- 数据清洗（过滤 value ≤ 0 的记录）
- 设备选择（选择数据最完整的设备）
- 数据聚合（支持按小时聚合）

### 2.2 关键代码逻辑

#### 2.2.1 数据扫描和加载
```python
def load_metric_data():
    """加载存储空间使用率数据"""
    data_file = '/Users/weiyi/code/darts_demo/data/tb_metric_raw_free_space_ratio_202509161435.csv'
    
    if not os.path.exists(data_file):
        raise FileNotFoundError(f"数据文件不存在: {data_file}")
    
    # 读取数据
    df = pd.read_csv(data_file)
    
    # 转换时间列
    df['datetime'] = pd.to_datetime(df['time'])
    
    # 过滤有效数据 (value > 0，去除连接失败的数据)
    valid_data = df[df['value'] > 0].copy()
    
    # 选择数据最完整的设备
    device_counts = valid_data['ci_id'].value_counts()
    best_device = device_counts.index[0]
    
    # 获取最佳设备的数据
    device_data = valid_data[valid_data['ci_id'] == best_device].copy()
    device_data = device_data.sort_values('datetime')
    
    # 按小时聚合数据（减少数据量，提高预测效果）
    device_data.set_index('datetime', inplace=True)
    hourly_data = device_data['value'].resample('H').mean().dropna()
    
    return hourly_data, best_device
```

#### 2.2.2 数据验证和清洗
```python
def validate_and_clean_data(df):
    """
    验证并清洗数据
    """
    # 检查必需字段
    required_columns = ['time', 'ci_id', 'value']
    if not all(col in df.columns for col in required_columns):
        raise ValueError("数据缺少必需的列: time, ci_id, value")
    
    # 转换时间格式
    df['time'] = pd.to_datetime(df['time'])
    
    # 过滤无效数据 (value <= 0)
    df = df[df['value'] > 0]
    
    # 按时间排序
    df = df.sort_values('time')
    
    return df
```

#### 2.2.3 设备选择逻辑
```python
def select_best_device(df):
    """
    选择数据最完整的设备
    """
    device_counts = df['ci_id'].value_counts()
    best_device = device_counts.index[0]  # 选择数据量最大的设备
    return df[df['ci_id'] == best_device]
```

#### 2.2.4 数据聚合逻辑
```python
def aggregate_data(df, freq='H'):
    """
    按指定频率聚合数据
    """
    df = df.set_index('time')
    aggregated = df.groupby('ci_id').resample(freq).mean(numeric_only=True)
    aggregated = aggregated.reset_index()
    return aggregated
```

#### 2.2.5 API 接口实现
```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/api/data/info', methods=['GET'])
def get_data_info():
    """获取数据信息"""
    try:
        series_data, device_id = load_metric_data()
        
        response = {
            'device_id': device_id,
            'total_points': len(series_data),
            'date_range': {
                'start': series_data.index.min().strftime('%Y-%m-%d %H:%M:%S'),
                'end': series_data.index.max().strftime('%Y-%m-%d %H:%M:%S')
            },
            'frequency': 'hourly',
            'statistics': {
                'mean': float(series_data.mean()),
                'std': float(series_data.std()),
                'min': float(series_data.min()),
                'max': float(series_data.max()),
                'median': float(series_data.median())
            }
        }
        
        return jsonify(response)
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/data/preview', methods=['GET'])
def preview_data():
    """预览数据"""
    try:
        series_data, device_id = load_metric_data()
        
        # 返回最近100个数据点
        preview_data = series_data.tail(100)
        
        response = {
            'device_id': device_id,
            'data': {
                'dates': preview_data.index.strftime('%Y-%m-%d %H:%M:%S').tolist(),
                'values': preview_data.values.tolist()
            },
            'total_points': len(series_data),
            'preview_points': len(preview_data),
            'date_range': {
                'start': series_data.index.min().strftime('%Y-%m-%d %H:%M:%S'),
                'end': series_data.index.max().strftime('%Y-%m-%d %H:%M:%S')
            }
        }
        
        return jsonify(response)
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

## 3. 前端实现逻辑

### 3.1 数据加载状态管理
前端需要管理数据加载的不同状态：
- 加载中
- 加载成功
- 加载失败

### 3.2 数据信息展示
```javascript
// 获取数据信息
async function loadDataInfo() {
    try {
        showLoadingIndicator();
        
        const response = await fetch('/api/data/info');
        const result = await response.json();
        
        if (result.status === 'success') {
            displayDataInfo(result.data);
        } else {
            showError(result.message);
        }
    } catch (error) {
        showError('获取数据信息失败: ' + error.message);
    } finally {
        hideLoadingIndicator();
    }
}

// 展示数据信息
function displayDataInfo(dataInfo) {
    document.getElementById('totalRecords').textContent = dataInfo.total_records;
    document.getElementById('deviceCount').textContent = dataInfo.device_count;
    document.getElementById('timeRange').textContent = 
        `${dataInfo.time_range.start} 到 ${dataInfo.time_range.end}`;
    document.getElementById('valueRange').textContent = 
        `最小: ${dataInfo.value_range.min}, 最大: ${dataInfo.value_range.max}, 平均: ${dataInfo.value_range.mean.toFixed(2)}`;
}
```

### 3.3 数据预览功能
```javascript
// 获取数据预览
async function loadDataPreview() {
    try {
        showLoadingIndicator();
        
        const response = await fetch('/api/data/preview');
        const result = await response.json();
        
        if (result.status === 'success') {
            displayDataPreview(result.data);
        } else {
            showError(result.message);
        }
    } catch (error) {
        showError('获取数据预览失败: ' + error.message);
    } finally {
        hideLoadingIndicator();
    }
}

// 展示数据预览
function displayDataPreview(data) {
    const tbody = document.querySelector('#dataPreviewTable tbody');
    tbody.innerHTML = '';
    
    data.forEach(row => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${row.time}</td>
            <td>${row.ci_id}</td>
            <td>${row.value.toFixed(2)}</td>
        `;
        tbody.appendChild(tr);
    });
}
```

### 3.4 用户界面更新
```javascript
// 显示加载指示器
function showLoadingIndicator() {
    document.getElementById('loadingIndicator').style.display = 'block';
    document.getElementById('errorMessage').style.display = 'none';
}

// 隐藏加载指示器
function hideLoadingIndicator() {
    document.getElementById('loadingIndicator').style.display = 'none';
}

// 显示错误信息
function showError(message) {
    document.getElementById('errorMessage').textContent = message;
    document.getElementById('errorMessage').style.display = 'block';
}
```

## 4. 测试方案实现思路

### 4.1 单元测试

#### 4.1.1 数据加载函数测试
```python
import unittest
import pandas as pd
import tempfile
import os

class TestDataLoading(unittest.TestCase):
    def setUp(self):
        # 创建临时目录和测试数据
        self.test_dir = tempfile.mkdtemp()
        self.test_data = pd.DataFrame({
            'time': ['2024-01-01 00:00:00', '2024-01-01 01:00:00', '2024-01-01 02:00:00'],
            'ci_id': ['device_001', 'device_001', 'device_001'],
            'value': [65.5, 66.2, 67.1]
        })
        self.test_file = os.path.join(self.test_dir, 'test_data.csv')
        self.test_data.to_csv(self.test_file, index=False)
    
    def tearDown(self):
        # 清理临时文件
        os.remove(self.test_file)
        os.rmdir(self.test_dir)
    
    def test_load_data_from_directory(self):
        # 测试数据加载功能
        data = load_data_from_directory(self.test_dir)
        self.assertEqual(len(data), 3)
        self.assertTrue(all(col in data.columns for col in ['time', 'ci_id', 'value']))
    
    def test_validate_and_clean_data(self):
        # 测试数据验证和清洗
        raw_data = pd.DataFrame({
            'time': ['2024-01-01 00:00:00', '2024-01-01 01:00:00', '2024-01-01 02:00:00'],
            'ci_id': ['device_001', 'device_001', 'device_001'],
            'value': [65.5, -1, 67.1]  # 包含无效值
        })
        
        clean_data = validate_and_clean_data(raw_data)
        self.assertEqual(len(clean_data), 2)  # 无效值应被过滤
        self.assertTrue((clean_data['value'] > 0).all())
```

#### 4.1.2 设备选择逻辑测试
```python
class TestDeviceSelection(unittest.TestCase):
    def test_select_best_device(self):
        # 测试设备选择逻辑
        test_data = pd.DataFrame({
            'time': pd.date_range('2024-01-01', periods=10, freq='H'),
            'ci_id': ['device_001'] * 4 + ['device_002'] * 6,  # device_002 数据更多
            'value': range(10)
        })
        
        selected_data = select_best_device(test_data)
        self.assertTrue((selected_data['ci_id'] == 'device_002').all())
        self.assertEqual(len(selected_data), 6)
```

### 4.2 接口测试

#### 4.2.1 API 端点测试
```python
import pytest
from app import app

class TestDataAPI:
    def setup_method(self):
        self.app = app.test_client()
        self.app.testing = True
    
    def test_data_info_endpoint(self):
        # 测试 /api/data/info 端点
        response = self.app.get('/api/data/info')
        assert response.status_code == 200
        
        data = response.get_json()
        assert 'device_id' in data
        assert 'total_points' in data
        assert 'date_range' in data
        
    def test_data_preview_endpoint(self):
        # 测试 /api/data/preview 端点
        response = self.app.get('/api/data/preview')
        assert response.status_code == 200
        
        data = response.get_json()
        assert 'device_id' in data
        assert 'data' in data
```

### 4.3 集成测试

#### 4.3.1 完整数据流程测试
```python
class TestDataIntegration:
    def test_complete_data_flow(self):
        # 测试从数据加载到预览的完整流程
        # 1. 创建测试数据文件
        # 2. 调用数据加载API
        # 3. 验证返回的数据结构
        # 4. 调用数据预览API
        # 5. 验证预览数据格式
        pass
```

### 4.4 测试用例示例

#### 4.4.1 正常情况测试
- 数据目录中有多个CSV文件
- 文件格式正确
- 包含所有必需字段
- 数据质量良好

#### 4.4.2 异常情况测试
- 数据目录为空
- CSV文件格式错误
- 缺少必需字段
- 包含大量无效数据 (value ≤ 0)
- 时间格式不正确

#### 4.4.3 边界情况测试
- 只有一个设备的数据
- 设备数据量相同（测试选择逻辑）
- 大量数据文件（性能测试）
- 包含特殊字符的设备ID

通过以上测试方案，可以确保数据加载功能的稳定性和可靠性，为整个时间序列预测系统提供高质量的数据基础。